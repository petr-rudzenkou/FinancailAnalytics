using System;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.ComTypes;
using System.Windows.Threading;
using FinancialAnalytics.Wrappers.Office;
using FinancialAnalytics.Wrappers.Excel.Interception;
using FinancialAnalytics.Wrappers.Office;

namespace FinancialAnalytics.Wrappers.Excel
{
    /// <summary>
    /// This class forces processing of events generated by Excel 2013 to prevent VBA macro crash.
    /// See crash in http://www.iajira.amers.ime.reuters.com/browse/TRMO-5465 
    /// </summary>
    public class ExcelEventsPumping : IDisposable
    {
        private const int ClosedWorkbooksCountToRunPumping = 20;
        private static ExcelEventsPumping _current;
        private readonly Microsoft.Office.Interop.Excel._Application _application;
        private readonly object _lock;
        private IConnectionPoint _connectionPoint;
        private int _cookie;
        private volatile int _closedWorkbooksCount;

        private ExcelEventsPumping(Microsoft.Office.Interop.Excel._Application application)
        {
            _lock = new object();
            _application = application;
            SetupEventsConnection();
        }

        [DispId(0x00000622)]
        public void OnWorkbookBeforeClose(Microsoft.Office.Interop.Excel._Workbook excelWorkbook, ref bool cancel)
        {
            ComObjectsFinalizer.ReleaseComObject(excelWorkbook);
            DoPumping();
        }

        private void DoPumping()
        {
            lock (_lock)
            {
                if (_closedWorkbooksCount >= ClosedWorkbooksCountToRunPumping)
                {
                    DoEvents();
                    _closedWorkbooksCount = 0;
                }
                else
                {
                    _closedWorkbooksCount++;
                }
            }
        }


        public static void DoEvents()
        {
            //--- WinForms -----
            //System.Windows.Forms.Application.DoEvents();
            //--- WPF ----------
            DispatcherFrame frame = new DispatcherFrame();
            Dispatcher.CurrentDispatcher.BeginInvoke(DispatcherPriority.Background, new ExitFrameHandler(frm => frm.Continue = false), frame);
            Dispatcher.PushFrame(frame);
        }

        private delegate void ExitFrameHandler(DispatcherFrame frame);

        public void Dispose()
        {
            RemoveEventsConnection();
        }

        private void SetupEventsConnection()
        {
            if (_connectionPoint == null)
            {
                using (StaComCrossThreadInvoker invoker = new StaComCrossThreadInvoker())
                {
                    using (new EnUsCultureInvoker())
                    {
                        if (_cookie != 0)
                        {
                            return;
                        }
                        var guid = new Guid(Application.EXCEL_APPLICATION_EVENTS_INTERFACE_GUID);
                        var connPointContainer = (IConnectionPointContainer)_application;
                        connPointContainer.FindConnectionPoint(ref guid, out _connectionPoint);
                        _connectionPoint.Advise(this, out _cookie);
                    }
                }
            }
        }

        private void RemoveEventsConnection()
        {
            if (_connectionPoint != null)
            {
                try
                {
                    using (new EnUsCultureInvoker())
                    {
                        if (_cookie != 0)
                        {
                            _connectionPoint.Unadvise(_cookie);
                        }
                    }
                }
                catch
                {
                    // seem that next code involves disposing communication/eventing with externally acquired processes/dependencies which can fail
                    // but it should not prevent us from releasing everything
                }
                ComObjectsFinalizer.ReleaseComObject(_connectionPoint);
                _connectionPoint = null;
                _cookie = 0;
            }
        }

        public static void Initialize(object application)
        {
            if (_current != null)
            {
                return;
            }
            _current = new ExcelEventsPumping((Microsoft.Office.Interop.Excel.Application)application);
        }

        public static void Release()
        {
            if (_current != null)
            {
                _current.Dispose();
                _current = null;
            }
        }
    }
}
